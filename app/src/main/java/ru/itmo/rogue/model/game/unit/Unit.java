package ru.itmo.rogue.model.game.unit;


import ru.itmo.rogue.model.game.unit.items.Item;
import ru.itmo.rogue.model.state.State;
import ru.itmo.rogue.model.state.UnitPositionUpdate;
import ru.itmo.rogue.model.state.UnitUpdate;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

public class Unit {
    protected int maxHealth;
    protected int health;
    protected int strength;
    protected int experience;
    protected int level;
    protected List<Item> stash = new ArrayList<>();
    protected Position position;
    protected Strategy strategy;

    public int levelUpCondition() {
        return (int) Math.ceil(Math.log(level + 1) * 10);
    }

    private int levelUpStrengthBonus() {
        return 2; // TODO: Maybe not constant
    }

    private int levelUpHealthBonus() {
        return 2;
    }

    private char aliveChar;
    private char deadChar;


    public Unit(int maxHealth, int strength, int experience, int level, Position position, Strategy strategy, char aliveChar, char deadChar ) {
        this.maxHealth = maxHealth;
        this.health = maxHealth;
        this.experience = experience;
        this.level = level;
        this.strength = strength;
        this.position = position;
        this.strategy = strategy;
        this.aliveChar = aliveChar;
        this.deadChar = deadChar;
    }

    public void setStrategy(Strategy strategy) {
        this.strategy = strategy;
    }

    public void wipeExperience() {
        this.experience = 0;
        this.level = 0;
    }

    public Action getAction(State state) {
        if (isDead())
            return new Action(getPosition());
        var action = strategy.getAction(this, state);
        this.strategy = strategy.nextStrategy();
        return action;
    }

    public UnitPositionUpdate moveTo(Position pos) {
        Position oldPos = position;
        position = pos;
        return new UnitPositionUpdate(this, oldPos);
    }

    public UnitPositionUpdate move(Movement movement) {
        Position oldPos = position;
        position = position.move(movement);
        return new UnitPositionUpdate(this, oldPos);
    }

    /**
     * @param change change in health, positive number increases health, negative - decreases
     * @return delta of the state generated by the change
     */
    public UnitUpdate changeHealth(int change) {
        health = (-change >= health) ? 0 : health + change;
        health = Math.min(maxHealth, health);
        return new UnitUpdate(this);
    }

    public UnitUpdate changeStrength(int change) {
        strength = (-change >= strength) ? 0 : strength + change;
        return new UnitUpdate(this);
    }

    public UnitUpdate increaseExperience(int change) {
        experience += change;

        if (experience >= levelUpCondition()) {
            return levelUp();
        }

        return new UnitUpdate(this);
    }

    public UnitUpdate levelUp() {
        experience = 0;
        level += 1;

        maxHealth += levelUpHealthBonus();
        health += levelUpHealthBonus();
        strength += levelUpStrengthBonus();

        return new UnitUpdate(this);
    }

    public UnitUpdate setAliveChar(char aliveChar) {
        this.aliveChar = aliveChar;
        return new UnitUpdate(this);
    }

    public UnitUpdate setDeadChar(char deadChar) {
        this.deadChar = deadChar;
        return new UnitUpdate(this);
    }

    public boolean isDead() {
        return health < 1;
    }

    public List<Item> getStash() {
        return stash;
    }

    public int getMaxHealth() {
        return maxHealth;
    }

    public int getHealth() {
        return health;
    }

    public int getStrength() {
        return strength;
    }

    public int getExperience() {
        return experience;
    }

    public int getLevel() {
        return level;
    }

    public int getHorizontalPos() {
        return position.getX();
    }

    public int getVerticalPos() {
        return position.getY();
    }

    public Position getPosition() {
        return position;
    }

    public Strategy getStrategy() {
        return strategy;
    }

    public char getAliveChar() {
        return aliveChar;
    }

    public char getDeadChar() {
        return deadChar;
    }


    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Unit unit = (Unit) o;
        return maxHealth == unit.maxHealth &&
                health == unit.health &&
                strength == unit.strength &&
                experience == unit.experience &&
                level == unit.level &&
                deadChar == unit.deadChar &&
                aliveChar == unit.aliveChar &&
                Objects.equals(stash, unit.stash) &&
                Objects.equals(position, unit.position) &&
                Objects.equals(strategy, unit.strategy);
    }

    @Override
    public int hashCode() {
        return Objects.hash(
                maxHealth,
                health,
                strength,
                experience,
                level,
                deadChar,
                aliveChar,
                stash,
                position,
                strategy);
    }
}
